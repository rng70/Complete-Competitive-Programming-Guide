<h1>Bit Trick</h1>

---

**This file contains some trick using bitwise operation. It’s my a little effort to collect them and put then in one file**



1. ***Turn of Rightmost Contiguous string of set-Bits:***

   Use the following formula to turn off the rightmost contiguous string of 1-bits (e.g. 01011000 –> 01000000)![u \atop \text{>>}](https://render.githubusercontent.com/render/math?math=u%20%5Catop%20%5Ctext%7B%3E%3E%7D)

   1. **Formula:**

      * **(((x | (x - 1)) + 1) & x)**

   2. **Formula:**

      * **(((x & -x) + x) & x)**

        

2. ***Average of Two Integers:***

   1. The following formula may be used to compute the average of two unsigned integers, ![\lfloor \frac{x+y}{2} \rfloor](https://render.githubusercontent.com/render/math?math=%5Clfloor%20%5Cfrac%7Bx%2By%7D%7B2%7D%20%5Crfloor) without causing overflow

      * **Formula:**
        * **(x & y) + ((x ![\oplus](https://render.githubusercontent.com/render/math?math=%5Coplus)y) ![u \atop \text{>>}](https://render.githubusercontent.com/render/math?math=u%20%5Catop%20%5Ctext%7B%3E%3E%7D) 1)**

   2. The formula below computes ![\lceil \frac{x+y}{2} \rceil ](https://render.githubusercontent.com/render/math?math=%5Clceil%20%5Cfrac%7Bx%2By%7D%7B2%7D%20%5Crceil%20) without causing overflow

      * **Formula:**
        * **(x | y) - ((x ![\oplus](https://render.githubusercontent.com/render/math?math=%5Coplus)y) ![u \atop \text{>>}](https://render.githubusercontent.com/render/math?math=u%20%5Catop%20%5Ctext%7B%3E%3E%7D) 1)**

      To compute the same quantities (“floor and ceiling averages”) for signed
      integers, use the same formulas but with the unsigned shift replaced with a signed
      shift.

      

3. **Next higher number with same set-Bits:**

   Given a number ***m*** and find the next smallest higher number ***r*** that has the same set bits.

   .i.e 

   ​			3 (0000011) => 5(0000101)
   ​			6(0000110) => 9(0001001)
   ​			11(0001011) => 13(0001101) 

   1. Observation:

      * 0000011 ==> 0000 <=…=> 011 (3) 

        ​							to 

      * 0000101 ==> 0000 <=…=> 101 (5)

   2. Observation:

      Now lets just look at what changed

      * 011 	   =>  101
      * 0110	  =>  1001
      * 011        =>  101
      * 0111      =>  1011
      * 011000 =>  100001
      * 01100   =>  10001
      * 01110   =>  10011

   3. Observation:

      * Before conversion:
        * 0 followed by
        * One or more 1’s (say x) followed by
        * Zero or more 0’s (say y)
      * After conversion:
        * 1 followed by
        * (y+1) zeros followed by
        * (x-1) 1’s

      **Algorithm:**

      * Given a bit-pattern, start from right, find successive zeroes
        (xxxx011110000)
      * Followed by zeroes find successive 1’s (xxxx011110000)
      * Stop on hitting a zero (xxxx011110000)
      * Interchange that zero with a 1 from successive 1’s
        (xxxx101110000)
      * Now move the remaining 1’s to extreme right, filling the
        gap with zeroes (xxxx100000111)

      **Code Segment**

      ```c++
      unsigned xchange(unsigned x){
          // given x value
          // for this purpose assume x = 1111 0000 (240)
          
          // wrape up all trailing zeros followed by one 1 bit
          smallest = x & -x; 
          // now smallest = 0001 0000
          
          // shift leftmost '1' to one position left
          ripple = x + smallest;
          // now ripple = 1 0000 0000
          
          // restoring all consecutive 1's of original bit stream
          ones = x ^ ripple;
          //ones = 1 1111 0000
          
          // make a bit stream with (x-1) 1's
          ones = (ones >> 2)/smallest;
          // ones = 0000 0111
          
          return ripple|ones;
          // returning 1 0000 0111
      }
      ```



4. 

